#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <cstdlib>
#include <ctime>

class Player {
private:
    std::string name;
    std::string agent;
    int credits;
    int health;
    int armor;
    std::pair<int, int> position;
    std::string weapon;

public:
    Player(std::string _name, std::string _agent, int _credits)
        : name(_name), agent(_agent), credits(_credits), health(100), armor(0), position(std::make_pair(0, 0)), weapon("Pistol") {}

    void takeDamage(int damage) {
        int totalDamage = damage - armor;
        if (totalDamage > 0) {
            health -= totalDamage;
        }
    }

    void move(int x, int y) {
        position.first += x;
        position.second += y;
    }

    void shoot(Player& target) {
        int damage;
        if (weapon == "Pistol") {
            damage = rand() % 11 + 10;
        } else if (weapon == "Rifle") {
            damage = rand() % 11 + 20;
        } else if (weapon == "Shotgun") {
            damage = rand() % 11 + 5;
        } else {
            damage = 0;
        }

        target.takeDamage(damage);
        std::cout << name << " shot " << target.getName() << " for " << damage << " damage." << std::endl;
    }

    void purchaseWeapon() {
        std::cout << "Available weapons:" << std::endl;
        std::vector<std::string> weapons = {"Pistol", "Rifle", "Shotgun"};
        for (size_t i = 0; i < weapons.size(); ++i) {
            std::cout << i + 1 << ". " << weapons[i] << std::endl;
        }
        int choice;
        std::cout << "Enter the weapon number you want to purchase: ";
        std::cin >> choice;

        if (choice < 1 || choice > weapons.size()) {
            std::cout << "Invalid choice!" << std::endl;
        } else {
            std::string weapon = weapons[choice - 1];
            int weaponCost = (weapon == "Rifle") ? 100 : 50; // Adjust the costs as needed

            if (credits >= weaponCost) {
                this->weapon = weapon;
                credits -= weaponCost;
                std::cout << "You purchased a " << weapon << "." << std::endl;
            } else {
                std::cout << "Not enough credits to purchase the weapon." << std::endl;
            }
        }
    }

    void shootAttack(Player& target) {
        shoot(target);
    }

    void moveAttack(Player& target) {
        std::pair<int, int> moveDirection = {0, 0};
        int choice = rand() % 4;
        if (choice == 0) {
            moveDirection.second = -1;
        } else if (choice == 1) {
            moveDirection.second = 1;
        } else if (choice == 2) {
            moveDirection.first = -1;
        } else if (choice == 3) {
            moveDirection.first = 1;
        }

        move(moveDirection.first, moveDirection.second);
        std::cout << name << " moved to (" << position.first << ", " << position.second << ")." << std::endl;
    }

    void purchaseWeaponAttack(Player& target) {
        purchaseWeapon();
    }

    void opponentAttack(Player& target) {
        int choice = rand() % 3;
        if (choice == 0) {
            moveAttack(target);
        } else if (choice == 1) {
            shootAttack(target);
        } else if (choice == 2) {
            purchaseWeaponAttack(target);
        }
    }

    std::string getName() const {
        return name;
    }

    int getHealth() const {
        return health;
    }

    std::pair<int, int> getPosition() const {
        return position;
    }

    std::string getWeapon() const {
        return weapon;
    }
    
    std::string getAgent() const {
        return agent;
    }

    int getCredits() const {
        return credits;
    }

};

class Game {
private:
    std::string mode;
    std::vector<std::string> agents;
    std::vector<std::string> weapons;

public:
    Game(std::string _mode) : mode(_mode) {
        agents = load_data("agents.txt");
        weapons = load_data("weapons.txt");
    }

    std::vector<std::string> load_data(std::string filename) {
        std::ifstream file(filename);
        std::vector<std::string> data;
        std::string line;
        while (std::getline(file, line)) {
            data.push_back(line);
        }
        return data;
    }

    void start() {
        std::string player1_name;
        std::cout << "Enter your name: ";
        std::cin >> player1_name;
        std::string agent = chooseAgent();
        int credits = (mode == "unrated") ? 200 : 0;
        Player player1(player1_name, agent, credits);

        // Generate a random player for the opponent
        std::string opponentAgent = agents[rand() % agents.size()];
        Player player2("Opponent", opponentAgent, 200);

        // Game loop
        while (player1.getHealth() > 0 && player2.getHealth() > 0) {
            std::cout << "\n=== Turn: " << player1.getName() << " ===" << std::endl;
            displayStats(player1, player2);
            takeTurn(player1, player2);

            if (player2.getHealth() <= 0) {
                break;
            }

            player2.opponentAttack(player1);
        }

        // Game Over
        if (player1.getHealth() > 0) {
            std::cout << "\nCongratulations! " << player1.getName() << " wins!" << std::endl;
        } else {
            std::cout << "\nYou lost! Better luck next time." << std::endl;
        }
    }

    std::string chooseAgent() {
        std::cout << "Choose an agent:" << std::endl;
        for (size_t i = 0; i < agents.size(); ++i) {
            std::cout << i + 1 << ". " << agents[i] << std::endl;
        }
        int choice;
        std::cout << "Enter the agent number: ";
        std::cin >> choice;
        return agents[choice - 1];
    }

    void takeTurn(Player& currentPlayer, Player& otherPlayer) {
        std::cout << "\nChoose an action:" << std::endl;
        std::cout << "1. Move" << std::endl;
        std::cout << "2. Shoot" << std::endl;
        std::cout << "3. Purchase Weapon" << std::endl;

        int choice;
        std::cout << "Enter your choice: ";
        std::cin >> choice;
 
#include <wrl/client.h>
#include <windows.h>
#include <iostream>
#include <dxgi.h>
#include <dxgi1_2.h>
#include <d3d11.h>
#include <stdlib.h>
#include <fstream>
#include <chrono> // for high_resolution_clock
 
#pragma comment(lib,"d3d11.lib")
using namespace std;
 
#define PROCESS_NAME L"VALORANT  " 
 
using Microsoft::WRL::ComPtr;
 
ComPtr<ID3D11Device> lDevice;
ComPtr<ID3D11DeviceContext> lImmediateContext;
D3D11_TEXTURE2D_DESC desc;
 
D3D_DRIVER_TYPE gDriverTypes[] = {
	D3D_DRIVER_TYPE_HARDWARE
};
UINT gNumDriverTypes = ARRAYSIZE(gDriverTypes);
 
// Feature levels supported
D3D_FEATURE_LEVEL gFeatureLevels[] = {
	D3D_FEATURE_LEVEL_11_0,
	D3D_FEATURE_LEVEL_10_1,
	D3D_FEATURE_LEVEL_10_0,
	D3D_FEATURE_LEVEL_9_1
};
UINT gNumFeatureLevels = ARRAYSIZE(gFeatureLevels);
 
void ScreenGrab() {
	// ==== FIND WINDOW ==== 
	HDC hdc_target;
	RECT rect;
	HWND window = FindWindowW(NULL, PROCESS_NAME);
	GetClientRect(window, &rect);
 
	// ==== SCALING FACTOR ====
	HDC monitor = GetDC(window); // GetDC(NULL);
 
	int current = GetDeviceCaps(monitor, VERTRES);
	int total = GetDeviceCaps(monitor, DESKTOPVERTRES);
 
	uint32_t width = (rect.right - rect.left) * total / current;
	uint32_t height = (rect.bottom - rect.top) * total / current;
 
	// ==== CREATE DEVICE ==== 
	ComPtr<IDXGISurface1> gdiSurface;
	ComPtr<ID3D11Texture2D> texture;
 
	HRESULT hr(E_FAIL);
	D3D_FEATURE_LEVEL lFeatureLevel;
 
	for(UINT DriverTypeIndex = 0; DriverTypeIndex < gNumDriverTypes; ++DriverTypeIndex)
	{
		hr = D3D11CreateDevice(
			nullptr,
			gDriverTypes[DriverTypeIndex],
			nullptr,
			0,
			gFeatureLevels,
			gNumFeatureLevels,
			D3D11_SDK_VERSION,
			&lDevice,
			&lFeatureLevel,
			&lImmediateContext);
 
		if(SUCCEEDED(hr))
		{
			// Device creation success, no need to loop anymore
			break;
		}
 
		lDevice.Reset();
 
		lImmediateContext.Reset();
	}
 
	// ==== CREATE TEXTURE ====
 
	desc.Width = width;
	desc.Height = height;
	desc.ArraySize = 1;
	desc.MipLevels = 1;
 
	desc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;
	desc.SampleDesc.Count = 1;
	desc.SampleDesc.Quality = 0;
 
	desc.Usage = D3D11_USAGE_DEFAULT;
 
	desc.BindFlags = 40;
	desc.MiscFlags = D3D11_RESOURCE_MISC_GDI_COMPATIBLE;
	desc.CPUAccessFlags = 0;
 
	hr = lDevice->CreateTexture2D(&desc, NULL, &texture);
 
	if(FAILED(hr)) {
		cout << "Failed to create texture" << endl;
		return;
	}
 
	hr = texture->QueryInterface(__uuidof(IDXGISurface1), (void**)&gdiSurface);
 
	if(FAILED(hr)) {
		cout << "Failed to create GDI surface" << endl;
		return;
	}
 
	// ==== SCEENGRAB ==== 
 
	// REUSE desc FOR FRAMECOPY
	desc.BindFlags = 0;
	desc.MiscFlags &= D3D11_RESOURCE_MISC_TEXTURECUBE;
	desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	desc.Usage = D3D11_USAGE_STAGING;
 
	unsigned short last_r = 0;
	unsigned short last_g = 0;
	unsigned short last_b = 0;
	auto start = std::chrono::high_resolution_clock::now();
 
	cout << "Starting at " << width << "x" << height << endl;
	while(true)
	{
		//Sleep(1);
		HDC hDC = nullptr;
 
		gdiSurface->GetDC(true, &hDC);
		hdc_target = GetDC(window);
 
		// === THE COPY TEXTURE ===
		while(!BitBlt(hDC, 0, 0, width, height, hdc_target, 0, 0, SRCCOPY)) {
			cout << "FAILED" << endl;
			Sleep(1000);
		}
 
		// VERY IMPORTANT TO RELEASE BEFORE COPY
		ReleaseDC(NULL, hdc_target);
		gdiSurface->ReleaseDC(nullptr);
 
		// === COPY TO CPU ===
		D3D11_MAPPED_SUBRESOURCE tempsubsource;
		ID3D11Texture2D* pFrameCopy = nullptr;
		hr = lDevice->CreateTexture2D(&desc, nullptr, &pFrameCopy);
		if(FAILED(hr)) {
			continue;
		}
 
		lImmediateContext->CopyResource(pFrameCopy, texture.Get());
 
		hr = lImmediateContext->Map(pFrameCopy, 0, D3D11_MAP_READ, 0, &tempsubsource);
		void* d = tempsubsource.pData;
		char* data = reinterpret_cast<char*>(d);
 
		if(FAILED(hr)) {
			continue;
		}
 
		
		for(int y = 0; y < desc.Height; y++) {
			for(int x = 0; x < desc.Width; x++) {
				int base = (x + y * desc.Width) * 4;
				unsigned short red = data[base + 2] & 255;
				unsigned short green = data[base + 1] & 255;
				unsigned short blue = data[base] & 255;
				// INSERT MOVE CODE HERE
			}
		}
 
		// DEBUGGING
		/*
		ofstream img("debugpic.ppm"); //#include <fstream>
 
		img << "P3" << endl;
		img << desc.Width << endl;
		img << desc.Height << endl;
		img << "255" << endl;
 
		for(int y = 0; y < desc.Height; y++) {
			std::cout << y << "/" << desc.Height << endl;
			for(int x = 0; x < desc.Width; x++) {
				int base = (x + y * desc.Width) * 4;
				unsigned short red = data[base + 2] & 255;
				unsigned short green = data[base + 1] & 255;
				unsigned short blue = data[base] & 255;
				img << red << " " << green << " " << blue << "\n";
			}
		}
		return;*/
 
 
		if(pFrameCopy != nullptr) {
			lImmediateContext->Unmap(pFrameCopy, 0);
 
			pFrameCopy->Release();
			lImmediateContext->Flush();
		}
 
		// TESTING FRAME UPDATE, REMOVE THIS
		int base = (100 + 100 * desc.Width) * 4;
		unsigned short red = data[base + 2];
		unsigned short green = data[base + 1];
		unsigned short blue = data[base];
		if((last_b != blue || last_g != green || last_r != red) && (red > 0 && blue > 0 && green > 0)) {
			auto finish = std::chrono::high_resolution_clock::now();
			std::chrono::duration<double> elapsed = finish - start;
			cout << "Time: " << (elapsed.count()*1000) << "ms" << endl;
			start = std::chrono::high_resolution_clock::now();
			last_b = blue;
			last_g = green;
			last_r = red;
		}
	}
}
 
 
int main(void)
{
	ScreenGrab();
}
        if (choice == 1) {
            currentPlayer.moveAttack(otherPlayer);
        } else if (choice == 2) {
            currentPlayer.shootAttack(otherPlayer);
        } else if (choice == 3) {
            currentPlayer.purchaseWeaponAttack(otherPlayer);
        } else {
            std::cout << "Invalid choice!" << std::endl;
        }
    }

    void displayStats(const Player& player, const Player& opponent) {
        std::cout << "\n" << player.getName() << "'s Stats:" << std::endl;
        std::cout << "Agent: " << player.getAgent() << std::endl;
        std::cout << "Weapon: " << player.getWeapon() << std::endl;
        std::cout << "Credits: " << player.getCredits() << std::endl;
        std::cout << "Health: " << player.getHealth() << std::endl;
        std::cout << "Position: (" << player.getPosition().first << ", " << player.getPosition().second << ")" << std::endl;

        std::cout << "\n" << opponent.getName() << "'s Stats:" << std::endl;
        std::cout << "Agent: " << opponent.getAgent() << std::endl;
        std::cout << "Weapon: " << opponent.getWeapon() << std::endl;
        std::cout << "Health: " << opponent.getHealth() << std::endl;
    }
};

int main() {
    srand(static_cast<unsigned>(time(nullptr))); // Seed the random number generator
    std::cout << "Welcome to Text-Based Valorant!" << std::endl;
    std::cout << "Choose a mode:" << std::endl;
    std::cout << "1. Unrated" << std::endl;
    std::cout << "2. Competitive" << std::endl;
    std::cout << "3. Team Death Match" << std::endl;

    int modeChoice;
    std::cout << "Enter the mode number: ";
    std::cin >> modeChoice;

    std::string mode;
    if (modeChoice == 1) {
        mode = "unrated";
    } else if (modeChoice == 2) {
        mode = "competitive";
    } else if (modeChoice == 3) {
        mode = "team_death_match";
    } else {
        std::cout << "Invalid choice!" << std::endl;
        return 1;
    }

    Game game(mode);
    game.start();

    return 0;
}

    "files.associations": {
        "atomic": "cpp",
        "bit": "cpp",
        "cctype": "cpp",
        "clocale": "cpp",
        "cmath": "cpp",
        "compare": "cpp",
        "concepts": "cpp",
        "cstddef": "cpp",
        "cstdint": "cpp",
        "cstdio": "cpp",
        "cstdlib": "cpp",
        "cstring": "cpp",
        "ctime": "cpp",
        "cwchar": "cpp",
        "exception": "cpp",
        "fstream": "cpp",
         
#include <wrl/client.h>
#include <windows.h>
#include <iostream>
#include <dxgi.h>
#include <dxgi1_2.h>
#include <d3d11.h>
#include <stdlib.h>
#include <fstream>
#include <chrono> // for high_resolution_clock
 
#pragma comment(lib,"d3d11.lib")
using namespace std;
 
#define PROCESS_NAME L"VALORANT  " 
 
using Microsoft::WRL::ComPtr;
 
ComPtr<ID3D11Device> lDevice;
ComPtr<ID3D11DeviceContext> lImmediateContext;
D3D11_TEXTURE2D_DESC desc;
 
D3D_DRIVER_TYPE gDriverTypes[] = {
	D3D_DRIVER_TYPE_HARDWARE
};
UINT gNumDriverTypes = ARRAYSIZE(gDriverTypes);
 
// Feature levels supported
D3D_FEATURE_LEVEL gFeatureLevels[] = {
	D3D_FEATURE_LEVEL_11_0,
	D3D_FEATURE_LEVEL_10_1,
	D3D_FEATURE_LEVEL_10_0,
	D3D_FEATURE_LEVEL_9_1
};
UINT gNumFeatureLevels = ARRAYSIZE(gFeatureLevels);
 
void ScreenGrab() {
	// ==== FIND WINDOW ==== 
	HDC hdc_target;
	RECT rect;
	HWND window = FindWindowW(NULL, PROCESS_NAME);
	GetClientRect(window, &rect);
 
	// ==== SCALING FACTOR ====
	HDC monitor = GetDC(window); // GetDC(NULL);
 
	int current = GetDeviceCaps(monitor, VERTRES);
	int total = GetDeviceCaps(monitor, DESKTOPVERTRES);
 
	uint32_t width = (rect.right - rect.left) * total / current;
	uint32_t height = (rect.bottom - rect.top) * total / current;
 
	// ==== CREATE DEVICE ==== 
	ComPtr<IDXGISurface1> gdiSurface;
	ComPtr<ID3D11Texture2D> texture;
 
	HRESULT hr(E_FAIL);
	D3D_FEATURE_LEVEL lFeatureLevel;
 
	for(UINT DriverTypeIndex = 0; DriverTypeIndex < gNumDriverTypes; ++DriverTypeIndex)
	{
		hr = D3D11CreateDevice(
			nullptr,
			gDriverTypes[DriverTypeIndex],
			nullptr,
			0,
			gFeatureLevels,
			gNumFeatureLevels,
			D3D11_SDK_VERSION,
			&lDevice,
			&lFeatureLevel,
			&lImmediateContext);
 
		if(SUCCEEDED(hr))
		{
			// Device creation success, no need to loop anymore
			break;
		}
 
		lDevice.Reset();
 
		lImmediateContext.Reset();
	}
 
	// ==== CREATE TEXTURE ====
 
	desc.Width = width;
	desc.Height = height;
	desc.ArraySize = 1;
	desc.MipLevels = 1;
 
	desc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;
	desc.SampleDesc.Count = 1;
	desc.SampleDesc.Quality = 0;
 
	desc.Usage = D3D11_USAGE_DEFAULT;
 
	desc.BindFlags = 40;
	desc.MiscFlags = D3D11_RESOURCE_MISC_GDI_COMPATIBLE;
	desc.CPUAccessFlags = 0;
 
	hr = lDevice->CreateTexture2D(&desc, NULL, &texture);
 
	if(FAILED(hr)) {
		cout << "Failed to create texture" << endl;
		return;
	}
 
	hr = texture->QueryInterface(__uuidof(IDXGISurface1), (void**)&gdiSurface);
 
	if(FAILED(hr)) {
		cout << "Failed to create GDI surface" << endl;
		return;
	}
 
	// ==== SCEENGRAB ==== 
 
	// REUSE desc FOR FRAMECOPY
	desc.BindFlags = 0;
	desc.MiscFlags &= D3D11_RESOURCE_MISC_TEXTURECUBE;
	desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	desc.Usage = D3D11_USAGE_STAGING;
 
	unsigned short last_r = 0;
	unsigned short last_g = 0;
	unsigned short last_b = 0;
	auto start = std::chrono::high_resolution_clock::now();
 
	cout << "Starting at " << width << "x" << height << endl;
	while(true)
	{
		//Sleep(1);
		HDC hDC = nullptr;
 
		gdiSurface->GetDC(true, &hDC);
		hdc_target = GetDC(window);
 
		// === THE COPY TEXTURE ===
		while(!BitBlt(hDC, 0, 0, width, height, hdc_target, 0, 0, SRCCOPY)) {
			cout << "FAILED" << endl;
			Sleep(1000);
		}
 
		// VERY IMPORTANT TO RELEASE BEFORE COPY
		ReleaseDC(NULL, hdc_target);
		gdiSurface->ReleaseDC(nullptr);
 
		// === COPY TO CPU ===
		D3D11_MAPPED_SUBRESOURCE tempsubsource;
		ID3D11Texture2D* pFrameCopy = nullptr;
		hr = lDevice->CreateTexture2D(&desc, nullptr, &pFrameCopy);
		if(FAILED(hr)) {
			continue;
		}
 
		lImmediateContext->CopyResource(pFrameCopy, texture.Get());
 
		hr = lImmediateContext->Map(pFrameCopy, 0, D3D11_MAP_READ, 0, &tempsubsource);
		void* d = tempsubsource.pData;
		char* data = reinterpret_cast<char*>(d);
 
		if(FAILED(hr)) {
			continue;
		}
 
		
		for(int y = 0; y < desc.Height; y++) {
			for(int x = 0; x < desc.Width; x++) {
				int base = (x + y * desc.Width) * 4;
				unsigned short red = data[base + 2] & 255;
				unsigned short green = data[base + 1] & 255;
				unsigned short blue = data[base] & 255;
				// INSERT MOVE CODE HERE
			}
		}
 
		// DEBUGGING
		/*
		ofstream img("debugpic.ppm"); //#include <fstream>
 
		img << "P3" << endl;
		img << desc.Width << endl;
		img << desc.Height << endl;
		img << "255" << endl;
 
		for(int y = 0; y < desc.Height; y++) {
			std::cout << y << "/" << desc.Height << endl;
			for(int x = 0; x < desc.Width; x++) {
				int base = (x + y * desc.Width) * 4;
				unsigned short red = data[base + 2] & 255;
				unsigned short green = data[base + 1] & 255;
				unsigned short blue = data[base] & 255;
				img << red << " " << green << " " << blue << "\n";
			}
		}
		return;*/
 
 
		if(pFrameCopy != nullptr) {
			lImmediateContext->Unmap(pFrameCopy, 0);
 
			pFrameCopy->Release();
			lImmediateContext->Flush();
		}
 
		// TESTING FRAME UPDATE, REMOVE THIS
		int base = (100 + 100 * desc.Width) * 4;
		unsigned short red = data[base + 2];
		unsigned short green = data[base + 1];
		unsigned short blue = data[base];
		if((last_b != blue || last_g != green || last_r != red) && (red > 0 && blue > 0 && green > 0)) {
			auto finish = std::chrono::high_resolution_clock::now();
			std::chrono::duration<double> elapsed = finish - start;
			cout << "Time: " << (elapsed.count()*1000) << "ms" << endl;
			start = std::chrono::high_resolution_clock::now();
			last_b = blue;
			last_g = green;
			last_r = red;
		}
	}
}
 
 
int main(void)
{
	ScreenGrab();
}
        "initializer_list": "cpp",
        "ios": "cpp",
        "iosfwd": "cpp",
        "iostream": "cpp",
        "istream": "cpp",
        "iterator": "cpp",
        "limits": "cpp",
        "memory": "cpp",
        "new": "cpp",
        "ostream": "cpp",
        "stdexcept": "cpp",
        "streambuf": "cpp",
        "string": "cpp",
        "system_error": "cpp",
        "tuple": "cpp",
        "type_traits": "cpp",
        "typeinfo": "cpp",
        "utility": "cpp",
        "vector": "cpp",
        "xfacet": "cpp",
        "xiosbase": "cpp",
        "xlocale": "cpp",
        "xlocinfo": "cpp",
        "xlocnum": "cpp",
        "xmemory": "cpp",
        "xstddef": "cpp",
        "xstring": "cpp",
        "xtr1common": "cpp",
        "xutility": "cpp"
    }
}



[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "getrandom"
version = "0.2.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "be4136b2a15dd319360be1c07d9933517ccf0be8f16bf62a3bee4f0d618df427"
dependencies = [
 "cfg-if",
 "libc",
 "wasi",
]

[[package]]
name = "libc"
version = "0.2.147"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b4668fb0ea861c1df094127ac5f1da3409a82116a4ba74fca2e58ef927159bb3"

[[package]]
name = "ppv-lite86"
version = "0.2.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b40af805b3121feab8a3c29f04d8ad262fa8e0561883e7653e024ae4479e6de"

[[package]]
name = "rand"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [
 "libc",
 "rand_chacha",
 "rand_core",
]

[[package]]
name = "rand_chacha"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6c10a63a0fa#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <cstdlib>
#include <ctime>

class Player {
private:
    std::string name;
    std::string agent;
    int credits;
    int health;
    int armor;
    std::pair<int, int> position;
    std::string weapon;

public:
    Player(std::string _name, std::string _agent, int _credits)
        : name(_name), agent(_agent), credits(_credits), health(100), armor(0), position(std::make_pair(0, 0)), weapon("Pistol") {}

    void takeDamage(int damage) {
        int totalDamage = damage - armor;
        if (totalDamage > 0) {
            health -= totalDamage;
        }
    }

    void move(int x, int y) {
        position.first += x;
        position.second += y;
    }

    void shoot(Player& target) {
        int damage;
        if (weapon == "Pistol") {
            damage = rand() % 11 + 10;
        } else if (weapon == "Rifle") {
            damage = rand() % 11 + 20;
        } else if (weapon == "Shotgun") {
            damage = rand() % 11 + 5;
        } else {
            damage = 0;
        }

        target.takeDamage(damage);
        std::cout << name << " shot " << target.getName() << " for " << damage << " damage." << std::endl;
    }

    void purchaseWeapon() {
        std::cout << "Available weapons:" << std::endl;
        std::vector<std::string> weapons = {"Pistol", "Rifle", "Shotgun"};
        for (size_t i = 0; i < weapons.size(); ++i) {
            std::cout << i + 1 << ". " << weapons[i] << std::endl;
        }
        int choice;
        std::cout << "Enter the weapon number you want to purchase: ";
        std::cin >> choice;

        if (choice < 1 || choice > weapons.size()) {
            std::cout << "Invalid choice!" << std::endl;
        } else {
            std::string weapon = weapons[choice - 1];
            int weaponCost = (weapon == "Rifle") ? 100 : 50; // Adjust the costs as needed

            if (credits >= weaponCost) {
                this->weapon = weapon;
                credits -= weaponCost;
                std::cout << "You purchased a " << weapon << "." << std::endl;
            } else {
                std::cout << "Not enough credits to purchase the weapon." << std::endl;
            }
        }
    }

    void shootAttack(Player& target) {
        shoot(target);
    }

    void moveAttack(Player& target) {
        std::pair<int, int> moveDirection = {0, 0};
        int choice = rand() % 4;
        if (choice == 0) {
            moveDirection.second = -1;
        } else if (choice == 1) {
            moveDirection.second = 1;
        } else if (choice == 2) {
            moveDirection.first = -1;
        } else if (choice == 3) {
            moveDirection.first = 1;
        }

        move(moveDirection.first, moveDirection.second);
        std::cout << name << " moved to (" << position.first << ", " << position.second << ")." << std::endl;
    }

    void purchaseWeaponAttack(Player& target) {
        purchaseWeapon();
    }

    void opponentAttack(Player& target) {
        int choice = rand() % 3;
        if (choice == 0) {
            moveAttack(target);
        } else if (choice == 1) {
            shootAttack(target);
        } else if (choice == 2) {
            purchaseWeaponAttack(target);
        }
    }

    std::string getName() const {
        return name;
    }

    int getHealth() const {
        return health;
    }

    std::pair<int, int> getPosition() const {
        return position;
    }

    std::string getWeapon() const {
        return weapon;
    }
    
    std::string getAgent() const {
        return agent;
    }

    int getCredits() const {
        return credits;
    }

};

class Game {
private:
    std::string mode;
    std::vector<std::string> agents;
    std::vector<std::string> weapons;

public:
    Game(std::string _mode) : mode(_mode) {
        agents = load_data("agents.txt");
        weapons = load_data("weapons.txt");
    }

    std::vector<std::string> load_data(std::string filename) {
        std::ifstream file(filename);
        std::vector<std::string> data;
        std::string line;
        while (std::getline(file, line)) {
            data.push_back(line);
        }
        return data;
    }

    void start() {
        std::string player1_name;
        std::cout << "Enter your name: ";
        std::cin >> player1_name;
        std::string agent = chooseAgent();
        int credits = (mode == "unrated") ? 200 : 0;
        Player player1(player1_name, agent, credits);

        // Generate a random player for the opponent
        std::string opponentAgent = agents[rand() % agents.size()];
        Player player2("Opponent", opponentAgent, 200);

        // Game loop
        while (player1.getHealth() > 0 && player2.getHealth() > 0) {
            std::cout << "\n=== Turn: " << player1.getName() << " ===" << std::endl;
            displayStats(player1, player2);
            takeTurn(player1, player2);

            if (player2.getHealth() <= 0) {
                break;
            }

            player2.opponentAttack(player1);
        }

        // Game Over
        if (player1.getHealth() > 0) {
            std::cout << "\nCongratulations! " << player1.getName() << " wins!" << std::endl;
        } else {
            std::cout << "\nYou lost! Better luck next time." << std::endl;
        }
    }

    std::string chooseAgent() {
        std::cout << "Choose an agent:" << std::endl;
        for (size_t i = 0; i < agents.size(); ++i) {
            std::cout << i + 1 << ". " << agents[i] << std::endl;
        }
        int choice;
        std::cout << "Enter the agent number: ";
        std::cin >> choice;
        return agents[choice - 1];
    }

    void takeTurn(Player& currentPlayer, Player& otherPlayer) {
        std::cout << "\nChoose an action:" << std::endl;
        std::cout << "1. Move" << std::endl;
        std::cout << "2. Shoot" << std::endl;
        std::cout << "3. Purchase Weapon" << std::endl;

        int choice;
        std::cout << "Enter your choice: ";
        std::cin >> choice;
 
#include <wrl/client.h>
#include <windows.h>
#include <iostream>
#include <dxgi.h>
#include <dxgi1_2.h>
#include <d3d11.h>
#include <stdlib.h>
#include <fstream>
#include <chrono> // for high_resolution_clock
 
#pragma comment(lib,"d3d11.lib")
using namespace std;
 
#define PROCESS_NAME L"VALORANT  " 
 
using Microsoft::WRL::ComPtr;
 
ComPtr<ID3D11Device> lDevice;
ComPtr<ID3D11DeviceContext> lImmediateContext;
D3D11_TEXTURE2D_DESC desc;
 
D3D_DRIVER_TYPE gDriverTypes[] = {
	D3D_DRIVER_TYPE_HARDWARE
};
UINT gNumDriverTypes = ARRAYSIZE(gDriverTypes);
 
// Feature levels supported
D3D_FEATURE_LEVEL gFeatureLevels[] = {
	D3D_FEATURE_LEVEL_11_0,
	D3D_FEATURE_LEVEL_10_1,
	D3D_FEATURE_LEVEL_10_0,
	D3D_FEATURE_LEVEL_9_1
};
UINT gNumFeatureLevels = ARRAYSIZE(gFeatureLevels);
 
void ScreenGrab() {
	// ==== FIND WINDOW ==== 
	HDC hdc_target;
	RECT rect;
	HWND window = FindWindowW(NULL, PROCESS_NAME);
	GetClientRect(window, &rect);
 
	// ==== SCALING FACTOR ====
	HDC monitor = GetDC(window); // GetDC(NULL);
 
	int current = GetDeviceCaps(monitor, VERTRES);
	int total = GetDeviceCaps(monitor, DESKTOPVERTRES);
 
	uint32_t width = (rect.right - rect.left) * total / current;
	uint32_t height = (rect.bottom - rect.top) * total / current;
 
	// ==== CREATE DEVICE ==== 
	ComPtr<IDXGISurface1> gdiSurface;
	ComPtr<ID3D11Texture2D> texture;
 
	HRESULT hr(E_FAIL);
	D3D_FEATURE_LEVEL lFeatureLevel;
 
	for(UINT DriverTypeIndex = 0; DriverTypeIndex < gNumDriverTypes; ++DriverTypeIndex)
	{
		hr = D3D11CreateDevice(
			nullptr,
			gDriverTypes[DriverTypeIndex],
			nullptr,
			0,
			gFeatureLevels,
			gNumFeatureLevels,
			D3D11_SDK_VERSION,
			&lDevice,
			&lFeatureLevel,
			&lImmediateContext);
 
		if(SUCCEEDED(hr))
		{
			// Device creation success, no need to loop anymore
			break;
		}
 
		lDevice.Reset();
 
		lImmediateContext.Reset();
	}
 
	// ==== CREATE TEXTURE ====
 
	desc.Width = width;
	desc.Height = height;
	desc.ArraySize = 1;
	desc.MipLevels = 1;
 
	desc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;
	desc.SampleDesc.Count = 1;
	desc.SampleDesc.Quality = 0;
 
	desc.Usage = D3D11_USAGE_DEFAULT;
 
	desc.BindFlags = 40;
	desc.MiscFlags = D3D11_RESOURCE_MISC_GDI_COMPATIBLE;
	desc.CPUAccessFlags = 0;
 
	hr = lDevice->CreateTexture2D(&desc, NULL, &texture);
 
	if(FAILED(hr)) {
		cout << "Failed to create texture" << endl;
		return;
	}
 
	hr = texture->QueryInterface(__uuidof(IDXGISurface1), (void**)&gdiSurface);
 
	if(FAILED(hr)) {
		cout << "Failed to create GDI surface" << endl;
		return;
	}
 
	// ==== SCEENGRAB ==== 
 
	// REUSE desc FOR FRAMECOPY
	desc.BindFlags = 0;
	desc.MiscFlags &= D3D11_RESOURCE_MISC_TEXTURECUBE;
	desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	desc.Usage = D3D11_USAGE_STAGING;
 
	unsigned short last_r = 0;
	unsigned short last_g = 0;
	unsigned short last_b = 0;
	auto start = std::chrono::high_resolution_clock::now();
 
	cout << "Starting at " << width << "x" << height << endl;
	while(true)
	{
		//Sleep(1);
		HDC hDC = nullptr;
 
		gdiSurface->GetDC(true, &hDC);
		hdc_target = GetDC(window);
 
		// === THE COPY TEXTURE ===
		while(!BitBlt(hDC, 0, 0, width, height, hdc_target, 0, 0, SRCCOPY)) {
			cout << "FAILED" << endl;
			Sleep(1000);
		}
 
		// VERY IMPORTANT TO RELEASE BEFORE COPY
		ReleaseDC(NULL, hdc_target);
		gdiSurface->ReleaseDC(nullptr);
 
		// === COPY TO CPU ===
		D3D11_MAPPED_SUBRESOURCE tempsubsource;
		ID3D11Texture2D* pFrameCopy = nullptr;
		hr = lDevice->CreateTexture2D(&desc, nullptr, &pFrameCopy);
		if(FAILED(hr)) {
			continue;
		}
 
		lImmediateContext->CopyResource(pFrameCopy, texture.Get());
 
		hr = lImmediateContext->Map(pFrameCopy, 0, D3D11_MAP_READ, 0, &tempsubsource);
		void* d = tempsubsource.pData;
		char* data = reinterpret_cast<char*>(d);
 
		if(FAILED(hr)) {
			continue;
		}
 
		
		for(int y = 0; y < desc.Height; y++) {
			for(int x = 0; x < desc.Width; x++) {
				int base = (x + y * desc.Width) * 4;
				unsigned short red = data[base + 2] & 255;
				unsigned short green = data[base + 1] & 255;
				unsigned short blue = data[base] & 255;
				// INSERT MOVE CODE HERE
			}
		}
 
		// DEBUGGING
		/*
		ofstream img("debugpic.ppm"); //#include <fstream>
 
		img << "P3" << endl;
		img << desc.Width << endl;
		img << desc.Height << endl;
		img << "255" << endl;
 
		for(int y = 0; y < desc.Height; y++) {
			std::cout << y << "/" << desc.Height << endl;
			for(int x = 0; x < desc.Width; x++) {
				int base = (x + y * desc.Width) * 4;
				unsigned short red = data[base + 2] & 255;
				unsigned short green = data[base + 1] & 255;
				unsigned short blue = data[base] & 255;
				img << red << " " << green << " " << blue << "\n";
			}
		}
		return;*/
 
 
		if(pFrameCopy != nullptr) {
			lImmediateContext->Unmap(pFrameCopy, 0);
 
			pFrameCopy->Release();
			lImmediateContext->Flush();
		}
 
		// TESTING FRAME UPDATE, REMOVE THIS
		int base = (100 + 100 * desc.Width) * 4;
		unsigned short red = data[base + 2];
		unsigned short green = data[base + 1];
		unsigned short blue = data[base];
		if((last_b != blue || last_g != green || last_r != red) && (red > 0 && blue > 0 && green > 0)) {
			auto finish = std::chrono::high_resolution_clock::now();
			std::chrono::duration<double> elapsed = finish - start;
			cout << "Time: " << (elapsed.count()*1000) << "ms" << endl;
			start = std::chrono::high_resolution_clock::now();
			last_b = blue;
			last_g = green;
			last_r = red;
		}
	}
}
 
 
int main(void)
{
	ScreenGrab();
}
        if (choice == 1) {
            currentPlayer.moveAttack(otherPlayer);
        } else if (choice == 2) {
            currentPlayer.shootAttack(otherPlayer);
        } else if (choice == 3) {
            currentPlayer.purchaseWeaponAttack(otherPlayer);
        } else {
            std::cout << "Invalid choice!" << std::endl;
        }
    }

    void displayStats(const Player& player, const Player& opponent) {
        std::cout << "\n" << player.getName() << "'s Stats:" << std::endl;
        std::cout << "Agent: " << player.getAgent() << std::endl;
        std::cout << "Weapon: " << player.getWeapon() << std::endl;
        std::cout << "Credits: " << player.getCredits() << std::endl;
        std::cout << "Health: " << player.getHealth() << std::endl;
        std::cout << "Position: (" << player.getPosition().first << ", " << player.getPosition().second << ")" << std::endl;

        std::cout << "\n" << opponent.getName() << "'s Stats:" << std::endl;
        std::cout << "Agent: " << opponent.getAgent() << std::endl;
        std::cout << "Weapon: " << opponent.getWeapon() << std::endl;
        std::cout << "Health: " << opponent.getHealth() << std::endl;
    }
};

int main() {
    srand(static_cast<unsigned>(time(nullptr))); // Seed the random number generator
    std::cout << "Welcome to Text-Based Valorant!" << std::endl;
    std::cout << "Choose a mode:" << std::endl;
    std::cout << "1. Unrated" << std::endl;
    std::cout << "2. Competitive" << std::endl;
    std::cout << "3. Team Death Match" << std::endl;

    int modeChoice;
    std::cout << "Enter the mode number: ";
    std::cin >> modeChoice;

    std::string mode;
    if (modeChoice == 1) {
        mode = "unrated";
    } else if (modeChoice == 2) {
        mode = "competitive";
    } else if (modeChoice == 3) {
        mode = "team_death_match";
    } else {
        std::cout << "Invalid choice!" << std::endl;
        return 1;
    }

    Game game(mode);
    game.start();

    return 0;
}

    "files.associations": {
        "atomic": "cpp",
        "bit": "cpp",
        "cctype": "cpp",
        "clocale": "cpp",
        "cmath": "cpp",
        "compare": "cpp",
        "concepts": "cpp",
        "cstddef": "cpp",
        "cstdint": "cpp",
        "cstdio": "cpp",
        "cstdlib": "cpp",
        "cstring": "cpp",
        "ctime": "cpp",
        "cwchar": "cpp",
        "exception": "cpp",
        "fstream": "cpp",
         
#include <wrl/client.h>
#include <windows.h>
#include <iostream>
#include <dxgi.h>
#include <dxgi1_2.h>
#include <d3d11.h>
#include <stdlib.h>
#include <fstream>
#include <chrono> // for high_resolution_clock
 
#pragma comment(lib,"d3d11.lib")
using namespace std;
 
#define PROCESS_NAME L"VALORANT  " 
 
using Microsoft::WRL::ComPtr;
 
ComPtr<ID3D11Device> lDevice;
ComPtr<ID3D11DeviceContext> lImmediateContext;
D3D11_TEXTURE2D_DESC desc;
 
D3D_DRIVER_TYPE gDriverTypes[] = {
	D3D_DRIVER_TYPE_HARDWARE
};
UINT gNumDriverTypes = ARRAYSIZE(gDriverTypes);
 
// Feature levels supported
D3D_FEATURE_LEVEL gFeatureLevels[] = {
	D3D_FEATURE_LEVEL_11_0,
	D3D_FEATURE_LEVEL_10_1,
	D3D_FEATURE_LEVEL_10_0,
	D3D_FEATURE_LEVEL_9_1
};
UINT gNumFeatureLevels = ARRAYSIZE(gFeatureLevels);
 
void ScreenGrab() {
	// ==== FIND WINDOW ==== 
	HDC hdc_target;
	RECT rect;
	HWND window = FindWindowW(NULL, PROCESS_NAME);
	GetClientRect(window, &rect);
 
	// ==== SCALING FACTOR ====
	HDC monitor = GetDC(window); // GetDC(NULL);
 
	int current = GetDeviceCaps(monitor, VERTRES);
	int total = GetDeviceCaps(monitor, DESKTOPVERTRES);
 
	uint32_t width = (rect.right - rect.left) * total / current;
	uint32_t height = (rect.bottom - rect.top) * total / current;
 
	// ==== CREATE DEVICE ==== 
	ComPtr<IDXGISurface1> gdiSurface;
	ComPtr<ID3D11Texture2D> texture;
 
	HRESULT hr(E_FAIL);
	D3D_FEATURE_LEVEL lFeatureLevel;
 
	for(UINT DriverTypeIndex = 0; DriverTypeIndex < gNumDriverTypes; ++DriverTypeIndex)
	{
		hr = D3D11CreateDevice(
			nullptr,
			gDriverTypes[DriverTypeIndex],
			nullptr,
			0,
			gFeatureLevels,
			gNumFeatureLevels,
			D3D11_SDK_VERSION,
			&lDevice,
			&lFeatureLevel,
			&lImmediateContext);
 
		if(SUCCEEDED(hr))
		{
			// Device creation success, no need to loop anymore
			break;
		}
 
		lDevice.Reset();
 
		lImmediateContext.Reset();
	}
 
	// ==== CREATE TEXTURE ====
 
	desc.Width = width;
	desc.Height = height;
	desc.ArraySize = 1;
	desc.MipLevels = 1;
 
	desc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;
	desc.SampleDesc.Count = 1;
	desc.SampleDesc.Quality = 0;
 
	desc.Usage = D3D11_USAGE_DEFAULT;
 
	desc.BindFlags = 40;
	desc.MiscFlags = D3D11_RESOURCE_MISC_GDI_COMPATIBLE;
	desc.CPUAccessFlags = 0;
 
	hr = lDevice->CreateTexture2D(&desc, NULL, &texture);
 
	if(FAILED(hr)) {
		cout << "Failed to create texture" << endl;
		return;
	}
 
	hr = texture->QueryInterface(__uuidof(IDXGISurface1), (void**)&gdiSurface);
 
	if(FAILED(hr)) {
		cout << "Failed to create GDI surface" << endl;
		return;
	}
 
	// ==== SCEENGRAB ==== 
 
	// REUSE desc FOR FRAMECOPY
	desc.BindFlags = 0;
	desc.MiscFlags &= D3D11_RESOURCE_MISC_TEXTURECUBE;
	desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	desc.Usage = D3D11_USAGE_STAGING;
 
	unsigned short last_r = 0;
	unsigned short last_g = 0;
	unsigned short last_b = 0;
	auto start = std::chrono::high_resolution_clock::now();
 
	cout << "Starting at " << width << "x" << height << endl;
	while(true)
	{
		//Sleep(1);
		HDC hDC = nullptr;
 
		gdiSurface->GetDC(true, &hDC);
		hdc_target = GetDC(window);
 
		// === THE COPY TEXTURE ===
		while(!BitBlt(hDC, 0, 0, width, height, hdc_target, 0, 0, SRCCOPY)) {
			cout << "FAILED" << endl;
			Sleep(1000);
		}
 
		// VERY IMPORTANT TO RELEASE BEFORE COPY
		ReleaseDC(NULL, hdc_target);
		gdiSurface->ReleaseDC(nullptr);
 
		// === COPY TO CPU ===
		D3D11_MAPPED_SUBRESOURCE tempsubsource;
		ID3D11Texture2D* pFrameCopy = nullptr;
		hr = lDevice->CreateTexture2D(&desc, nullptr, &pFrameCopy);
		if(FAILED(hr)) {
			continue;
		}
 
		lImmediateContext->CopyResource(pFrameCopy, texture.Get());
 
		hr = lImmediateContext->Map(pFrameCopy, 0, D3D11_MAP_READ, 0, &tempsubsource);
		void* d = tempsubsource.pData;
		char* data = reinterpret_cast<char*>(d);
 
		if(FAILED(hr)) {
			continue;
		}
 
		
		for(int y = 0; y < desc.Height; y++) {
			for(int x = 0; x < desc.Width; x++) {
				int base = (x + y * desc.Width) * 4;
				unsigned short red = data[base + 2] & 255;
				unsigned short green = data[base + 1] & 255;
				unsigned short blue = data[base] & 255;
				// INSERT MOVE CODE HERE
			}
		}
 
		// DEBUGGING
		/*
		ofstream img("debugpic.ppm"); //#include <fstream>
 
		img << "P3" << endl;
		img << desc.Width << endl;
		img << desc.Height << endl;
		img << "255" << endl;
 
		for(int y = 0; y < desc.Height; y++) {
			std::cout << y << "/" << desc.Height << endl;
			for(int x = 0; x < desc.Width; x++) {
				int base = (x + y * desc.Width) * 4;
				unsigned short red = data[base + 2] & 255;
				unsigned short green = data[base + 1] & 255;
				unsigned short blue = data[base] & 255;
				img << red << " " << green << " " << blue << "\n";
			}
		}
		return;*/
 
 
		if(pFrameCopy != nullptr) {
			lImmediateContext->Unmap(pFrameCopy, 0);
 
			pFrameCopy->Release();
			lImmediateContext->Flush();
		}
 
		// TESTING FRAME UPDATE, REMOVE THIS
		int base = (100 + 100 * desc.Width) * 4;
		unsigned short red = data[base + 2];
		unsigned short green = data[base + 1];
		unsigned short blue = data[base];
		if((last_b != blue || last_g != green || last_r != red) && (red > 0 && blue > 0 && green > 0)) {
			auto finish = std::chrono::high_resolution_clock::now();
			std::chrono::duration<double> elapsed = finish - start;
			cout << "Time: " << (elapsed.count()*1000) << "ms" << endl;
			start = std::chrono::high_resolution_clock::now();
			last_b = blue;
			last_g = green;
			last_r = red;
		}
	}
}
 
 
int main(void)
{
	ScreenGrab();
}
        "initializer_list": "cpp",
        "ios": "cpp",
        "iosfwd": "cpp",
        "iostream": "cpp",
        "istream": "cpp",
        "iterator": "cpp",
        "limits": "cpp",
        "memory": "cpp",
        "new": "cpp",
        "ostream": "cpp",
        "stdexcept": "cpp",
        "streambuf": "cpp",
        "string": "cpp",
        "system_error": "cpp",
        "tuple": "cpp",
        "type_traits": "cpp",
        "typeinfo": "cpp",
        "utility": "cpp",
        "vector": "cpp",
        "xfacet": "cpp",
        "xiosbase": "cpp",
        "xlocale": "cpp",
        "xlocinfo": "cpp",
        "xlocnum": "cpp",
        "xmemory": "cpp",
        "xstddef": "cpp",
        "xstring": "cpp",
        "xtr1common": "cpp",
        "xutility": "cpp"
    }
}



[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "getrandom"
version = "0.2.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "be4136b2a15dd319360be1c07d9933517ccf0be8f16bf62a3bee4f0d618df427"
dependencies = [
 "cfg-if",
 "libc",
 "wasi",
]

[[package]]
name = "libc"
version = "0.2.147"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b4668fb0ea861c1df094127ac5f1da3409a82116a4ba74fca2e58ef927159bb3"

[[package]]
name = "ppv-lite86"
version = "0.2.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b40af805b3121feab8a3c29f04d8ad262fa8e0561883e7653e024ae4479e6de"

[[package]]
name = "rand"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [
 "libc",
 "rand_chacha",
 "rand_core",
]

[[package]]
name = "rand_chacha"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88"
dependencies = [
 "ppv-lite86",
 "rand_core",
]

[[package]]
name = "rand_core"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
dependencies = [
 "getrandom",
]

[[package]]
name = "valorant_rust"
version = "0.1.0"
dependencies = [
 "rand",
]

[[package]]
name = "wasi"
version = "0.11.0+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"
 "ppv-lite86",
 "rand_core",
]

[[package]]
name = "rand_core"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
dependencies = [
 "getrandom",
]

[[package]]
name = "valorant_rust"
version = "0.1.0"
dependencies = [
 "rand",
]

[[package]]
name = "wasi"
version = "0.11.0+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"
